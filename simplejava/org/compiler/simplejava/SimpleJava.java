/* Generated By:JavaCC: Do not edit this line. SimpleJava.java */
package org.compiler.simplejava;

import java.util.ArrayList;
import java.util.List;
import org.compiler.simplejava.ast.*;

public class SimpleJava implements SimpleJavaConstants {

  final public AstProgram program() throws ParseException {
  AstClasses astClasses;
  AstFunctionDefinitions astFunctionDefinitions;
    astClasses = classDefinitions();
    astFunctionDefinitions = functionDefinitions();
    jj_consume_token(0);
    {if (true) return new AstProgram(astClasses, astFunctionDefinitions, 1);}
    throw new Error("Missing return statement in function");
  }

  final public AstClasses classDefinitions() throws ParseException {
  AstClasses astClasses = new AstClasses();
  AstClass astClass;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      astClass = classDefinition();
                                   astClasses.addAstClass(astClass);
    }
    {if (true) return astClasses;}
    throw new Error("Missing return statement in function");
  }

  final public AstClass classDefinition() throws ParseException {
  Token classNameToken;
  Token functionDefTypeToken;
  Token firstIdentifier;
  Token secondIdentifier;
  AstInstanceVariableDefs astInstanceVariableDefs = new AstInstanceVariableDefs();
  AstFunctionDefinitions astMethodDefinitions = new AstFunctionDefinitions();
  AstFunction astConstructor = null;
  AstStatements astStatements = null;
  AstFormals astFormals;
  int arrayDimension = 0;
  AstFunction constructor = null;
    jj_consume_token(CLASS);
    classNameToken = jj_consume_token(IDENTIFIER);
    jj_consume_token(LEFT_BRACE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      firstIdentifier = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        // Rules for Variable definitions, methods and prototypes.
                      secondIdentifier = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_BRACKET:
        case SEMICOLON:
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LEFT_BRACKET:
              ;
              break;
            default:
              jj_la1[2] = jj_gen;
              break label_3;
            }
            jj_consume_token(LEFT_BRACKET);
            jj_consume_token(RIGHT_BRACKET);
                                                  arrayDimension++;
          }
          jj_consume_token(SEMICOLON);
                  AstInstanceVariableDef astInstanceVariableDef = new AstInstanceVariableDef(firstIdentifier.image, secondIdentifier.image, arrayDimension, firstIdentifier.beginLine);
                  astInstanceVariableDefs.addAstInstanceVariableDef(astInstanceVariableDef);
                  arrayDimension = 0;
          break;
        case LEFT_PARENTHESIS:
          jj_consume_token(LEFT_PARENTHESIS);
          astFormals = formalParameterList();
          jj_consume_token(RIGHT_PARENTHESIS);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            functionDefTypeToken = jj_consume_token(SEMICOLON);
            break;
          case LEFT_BRACE:
            functionDefTypeToken = jj_consume_token(LEFT_BRACE);
            astStatements = statementList();
            jj_consume_token(RIGHT_BRACE);
            break;
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                  if (functionDefTypeToken.kind == SEMICOLON) {
                    // Adding the function prototype.
                    AstPrototype astPrototype = new AstPrototype(firstIdentifier.image, secondIdentifier.image, astFormals, FunctionType.METHOD, firstIdentifier.beginLine);
                    astMethodDefinitions.addAstFunctionDefinition(astPrototype);
                  } else {
                    // Adding the function.
                    AstFunction astFunction = new AstFunction(firstIdentifier.image, secondIdentifier.image, astFormals, astStatements, FunctionType.METHOD, firstIdentifier.beginLine);
                    astMethodDefinitions.addAstFunctionDefinition(astFunction);
                  }
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        astFormals = formalParameterList();
        jj_consume_token(RIGHT_PARENTHESIS);
        functionDefTypeToken = jj_consume_token(LEFT_BRACE);
        astStatements = statementList();
        jj_consume_token(RIGHT_BRACE);
              // Adding the constructor (The return type and the name are the same for the constructors).
          astConstructor = new AstFunction(firstIdentifier.image, firstIdentifier.image, astFormals, astStatements, FunctionType.CONSTRUCTOR, firstIdentifier.beginLine);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RIGHT_BRACE);
    {if (true) return new AstClass(classNameToken.image, astInstanceVariableDefs, astConstructor, astMethodDefinitions, classNameToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstInstanceVariableDefs variableDefinitions() throws ParseException {
  AstInstanceVariableDefs astInstanceVariableDefs = new AstInstanceVariableDefs();
  AstInstanceVariableDef astInstanceVariableDef;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      astInstanceVariableDef = variableDefinition();
      jj_consume_token(SEMICOLON);
      astInstanceVariableDefs.addAstInstanceVariableDef(astInstanceVariableDef);
    }
    {if (true) return astInstanceVariableDefs;}
    throw new Error("Missing return statement in function");
  }

  final public AstInstanceVariableDef variableDefinition() throws ParseException {
  Token typeToken;
  Token nameToken;
  int arrayDimension = 0;
    typeToken = jj_consume_token(IDENTIFIER);
    nameToken = jj_consume_token(IDENTIFIER);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      jj_consume_token(LEFT_BRACKET);
      jj_consume_token(RIGHT_BRACKET);
                                      arrayDimension++;
    }
    {if (true) return new AstInstanceVariableDef(typeToken.image, nameToken.image, arrayDimension, typeToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstFunctionDefinitions functionDefinitions() throws ParseException {
  AstFunctionDefinitions astFunctionDefinitions = new AstFunctionDefinitions();
  AstFunctionDefinition astFunctionDefinition;
  AstStatements astStatements = null;
  AstFormals astFormals;
  Token returnToken;
  Token nameToken;
  Token functionDefTypeToken;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_6;
      }
      returnToken = jj_consume_token(IDENTIFIER);
      nameToken = jj_consume_token(IDENTIFIER);
      jj_consume_token(LEFT_PARENTHESIS);
      astFormals = formalParameterList();
      jj_consume_token(RIGHT_PARENTHESIS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        functionDefTypeToken = jj_consume_token(SEMICOLON);
        break;
      case LEFT_BRACE:
        functionDefTypeToken = jj_consume_token(LEFT_BRACE);
        astStatements = statementList();
        jj_consume_token(RIGHT_BRACE);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (functionDefTypeToken.kind == SEMICOLON) {
        // Adding the function prototype.
        AstPrototype astPrototype = new AstPrototype(returnToken.image, nameToken.image, astFormals, returnToken.beginLine);
        astFunctionDefinitions.addAstFunctionDefinition(astPrototype);
      } else {
        // Adding the function.
        AstFunction astFunction = new AstFunction(returnToken.image, nameToken.image, astFormals, astStatements, returnToken.beginLine);
        astFunctionDefinitions.addAstFunctionDefinition(astFunction);
      }
    }
    {if (true) return astFunctionDefinitions;}
    throw new Error("Missing return statement in function");
  }

  final public AstFormals formalParameterList() throws ParseException {
  AstFormals astFormals = new AstFormals();
  AstFormal astFormal;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      astFormal = formalParameter();
                                  astFormals.addAstFormal(astFormal);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        astFormal = formalParameter();
                                            astFormals.addAstFormal(astFormal);
      }
    {if (true) return astFormals;}
      break;
    default:
      jj_la1[11] = jj_gen;
    {if (true) return astFormals;}
    }
    throw new Error("Missing return statement in function");
  }

  final public AstFormal formalParameter() throws ParseException {
  Token typeToken;
  Token nameToken;
  int arrayDimension = 0;
    typeToken = jj_consume_token(IDENTIFIER);
    nameToken = jj_consume_token(IDENTIFIER);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_8;
      }
      jj_consume_token(LEFT_BRACKET);
      jj_consume_token(RIGHT_BRACKET);
                                    arrayDimension++;
    }
    {if (true) return new AstFormal(typeToken.image, nameToken.image, arrayDimension, typeToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatements statementList() throws ParseException {
  AstStatements astStatements = new AstStatements();
  AstStatement astStatement;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
      case IF:
      case FOR:
      case RETURN:
      case WHILE:
      case LEFT_BRACE:
      case SEMICOLON:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_9;
      }
      astStatement = statement();
      astStatements.addAstStatement(astStatement);
    }
    {if (true) return astStatements;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement statement() throws ParseException {
  AstStatement stmt;
  Token semicolonToken;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_BRACE:
      stmt = blockStatement();
      break;
    case IF:
      stmt = ifStatement();
      break;
    case DO:
      stmt = doWhileStatement();
      break;
    case WHILE:
      stmt = whileStatement();
      break;
    case FOR:
      stmt = forStatement();
      break;
    case RETURN:
      stmt = returnStatement();
      break;
    case IDENTIFIER:
      stmt = variableOrFunctionStatement();
      break;
    case SEMICOLON:
      semicolonToken = jj_consume_token(SEMICOLON);
                                         stmt = new AstEmptyStatement(semicolonToken.beginLine);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement blockStatement() throws ParseException {
  AstStatements astStatements = new AstStatements();
    jj_consume_token(LEFT_BRACE);
    astStatements = statementList();
    jj_consume_token(RIGHT_BRACE);
    {if (true) return astStatements;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement doWhileStatement() throws ParseException {
  AstStatement stmt;
  AstExpression expr;
  Token doToken;
    // The semicolon is not required at the end of the right paranthesis.
      doToken = jj_consume_token(DO);
    stmt = statement();
    jj_consume_token(WHILE);
    jj_consume_token(LEFT_PARENTHESIS);
    expr = expression();
    jj_consume_token(RIGHT_PARENTHESIS);
    {if (true) return new AstDoWhileStatement(expr, stmt, doToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement whileStatement() throws ParseException {
  AstStatement stmt;
  AstExpression expr;
  Token whileToken;
    whileToken = jj_consume_token(WHILE);
    jj_consume_token(LEFT_PARENTHESIS);
    expr = expression();
    jj_consume_token(RIGHT_PARENTHESIS);
    stmt = statement();
    {if (true) return new AstWhileStatement(expr, stmt, whileToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement forStatement() throws ParseException {
  AstStatement initStmt = null;
  AstExpression testExpr = null;
  AstStatement incrementStmt = null;
  AstStatement bodyStmt;
  AstBaseVariable baseVariable;
  Token forToken;
  Token nameToken;
    forToken = jj_consume_token(FOR);
    jj_consume_token(LEFT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      initStmt = forInitialization();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case TRUE:
    case NEW:
    case MINUS:
    case LEFT_PARENTHESIS:
    case NOT:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      testExpr = expression();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      nameToken = jj_consume_token(IDENTIFIER);
                                          baseVariable = new AstBaseVariable(nameToken.image, nameToken.beginLine);
      incrementStmt = assignments(baseVariable);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
    bodyStmt = statement();
    if (initStmt == null) {
      initStmt = new AstEmptyStatement(forToken.beginLine);
    }

    if (testExpr == null) {
      testExpr = new AstBooleanLiteral(true, forToken.beginLine);
    }

    if (incrementStmt == null) {
      incrementStmt = new AstEmptyStatement(forToken.beginLine);
    }

    {if (true) return new AstForStatement(initStmt, testExpr, incrementStmt, bodyStmt, forToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement forInitialization() throws ParseException {
  AstStatement stmt;
  AstBaseVariable baseVariable;
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      // Passing the type
            stmt = declarations(nameToken.image);
      break;
    case INCREMENT:
    case DECREMENT:
    case LEFT_BRACKET:
    case DOT:
    case GETS:
          // Creating the base variable for the assigment.
          baseVariable = new AstBaseVariable(nameToken.image, nameToken.beginLine);
      // Passing the base variable
              stmt = assignments(baseVariable);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement assignments(AstVariable baseVariable) throws ParseException {
 AstStatements stmts = new AstStatements();
 AstStatement stmt = null;
 Token nameToken;
    baseVariable = leftVariable(baseVariable);
    stmt = assignment(baseVariable);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_10;
      }
        stmts.addAstStatement(stmt);
      jj_consume_token(COMMA);
      nameToken = jj_consume_token(IDENTIFIER);
          // Creating the base variable for the assigment.
          baseVariable = new AstBaseVariable(nameToken.image, nameToken.beginLine);
      baseVariable = leftVariable(baseVariable);
      stmt = assignment(baseVariable);
                                          stmts.addAstStatement(stmt);
    }
    if (stmts.getSize() > 0) {
      {if (true) return stmts;}
    }

    {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

// Returns assignment statements like a = 43 + 9
  final public AstStatement assignment(AstVariable baseVariable) throws ParseException {
  AstExpression expr = null;
  Token nameToken;
  Token incrementToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GETS:
      jj_consume_token(GETS);
      expr = expression();
      break;
    case INCREMENT:
      incrementToken = jj_consume_token(INCREMENT);
      break;
    case DECREMENT:
      incrementToken = jj_consume_token(DECREMENT);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (expr == null) {
      // The increment and decrement operators will be treated like a++ equals to a = a + 1
      int beginLine = incrementToken.beginLine;
      expr = new AstVariableExpression(baseVariable, beginLine);
      AstIntegerLiteral one = new AstIntegerLiteral(1, beginLine);
      if (incrementToken.kind == INCREMENT) {
        expr = new AstOperatorExpression(expr, one, AstOperatorExpression.PLUS, beginLine);
      } else {
        expr = new AstOperatorExpression(expr, one, AstOperatorExpression.MINUS, beginLine);
      }
    }

    {if (true) return new AstAssignmentStatement(baseVariable, expr, baseVariable.getLine());}
    throw new Error("Missing return statement in function");
  }

  final public AstVariable leftVariable(AstVariable baseVariable) throws ParseException {
  AstExpression arrayAccess;
  List<AstExpression> arguments = null;
  Token nameToken;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_11;
      }
      // Represents the derivations ( a[3][43][4] )
          arrayAccess = arrayAccess();
      // Represents Array variable.
      baseVariable = new AstArrayVariable(baseVariable, arrayAccess, baseVariable.getLine());
    }
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_12;
      }
      jj_consume_token(DOT);
      nameToken = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FALSE:
        case TRUE:
        case NEW:
        case MINUS:
        case LEFT_PARENTHESIS:
        case NOT:
        case INTEGER_LITERAL:
        case IDENTIFIER:
          arguments = arguments();
          break;
        default:
          jj_la1[23] = jj_gen;
          ;
        }
        jj_consume_token(RIGHT_PARENTHESIS);
        // Creating the method expression with its arguments.
        AstMethodVariable methodVariable = new AstMethodVariable(baseVariable, nameToken.image, nameToken.beginLine);
        if (arguments != null) {
          methodVariable.setExpressions(arguments);
        }

        baseVariable = methodVariable;
        break;
      default:
        jj_la1[25] = jj_gen;
            // Represents Class variable
            baseVariable = new AstClassVariable(baseVariable, nameToken.image, nameToken.beginLine);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEFT_BRACKET:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_13;
          }
          // Represents Array variable.
                        arrayAccess = arrayAccess();
                baseVariable = new AstArrayVariable(baseVariable, arrayAccess, nameToken.beginLine);
        }
      }
    }
    {if (true) return baseVariable;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement declarations(String type) throws ParseException {
 AstStatements stmts = new AstStatements();
 AstStatement stmt;
    stmt = declaration(type);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_14;
      }
       stmts.addAstStatement(stmt);
      jj_consume_token(COMMA);
      stmt = declaration(type);
                                                                         stmts.addAstStatement(stmt);
    }
    if (stmts.getSize() > 0)
      {if (true) return stmts;}

    {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement declaration(String type) throws ParseException {
  AstExpression expr = null;
  Token nameToken;
  int arrayDimension = 0;
    nameToken = jj_consume_token(IDENTIFIER);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_BRACKET:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_15;
      }
      jj_consume_token(LEFT_BRACKET);
      jj_consume_token(RIGHT_BRACKET);
                                                              arrayDimension++;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GETS:
      jj_consume_token(GETS);
      expr = expression();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    {if (true) return new AstVariableDefStatement(type, nameToken.image, arrayDimension, expr, nameToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement variableOrFunctionStatement() throws ParseException {
  AstStatement stmt = null;
  AstVariable baseVariable;
  Token nameToken;
  List<AstExpression> arguments = null;
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      // Passing the type (DECLARATIONS)
              stmt = declarations(nameToken.image);
      jj_consume_token(SEMICOLON);
      break;
    case INCREMENT:
    case DECREMENT:
    case LEFT_BRACKET:
    case DOT:
    case SEMICOLON:
    case GETS:
          // Creating the base variable for the assigment.
          baseVariable = new AstBaseVariable(nameToken.image, nameToken.beginLine);
      baseVariable = leftVariable(baseVariable);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCREMENT:
      case DECREMENT:
      case GETS:
        stmt = assignment(baseVariable);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
                  if (stmt == null) {
                    if (baseVariable instanceof AstMethodVariable) {
                      stmt = new AstMethodCallStatement((AstMethodVariable) baseVariable, nameToken.beginLine);
                    } else {
                      // variable.x.y.a; is an invalid statement.
                      {if (true) throw new ParseException("This is not a valid statement! " + nameToken.beginLine);}
                    }
                  }
      break;
    case LEFT_PARENTHESIS:
      jj_consume_token(LEFT_PARENTHESIS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FALSE:
      case TRUE:
      case NEW:
      case MINUS:
      case LEFT_PARENTHESIS:
      case NOT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        arguments = arguments();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PARENTHESIS);
      jj_consume_token(SEMICOLON);
          AstFunctionCallStatement functionStmt = new AstFunctionCallStatement(nameToken.image, nameToken.beginLine);
          if (arguments != null) {
            for (AstExpression arg : arguments)
              functionStmt.addAstExpression(arg);
          }

          stmt = functionStmt;
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return stmt;}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement ifStatement() throws ParseException {
  AstStatement ifStmt;
  AstStatement elseStmt = null;
  AstExpression testExpre;
  Token ifToken;
    ifToken = jj_consume_token(IF);
    jj_consume_token(LEFT_PARENTHESIS);
    testExpre = expression();
    jj_consume_token(RIGHT_PARENTHESIS);
    ifStmt = statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elseStmt = statement();
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    {if (true) return new AstIfStatement(testExpre, ifStmt, elseStmt, ifToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public AstStatement returnStatement() throws ParseException {
  AstExpression expr = null;
  Token returnToken;
    returnToken = jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case TRUE:
    case NEW:
    case MINUS:
    case LEFT_PARENTHESIS:
    case NOT:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      expr = expression();
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    {if (true) return new AstReturnStatement(expr, returnToken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  final public List<AstExpression> arguments() throws ParseException {
  List<AstExpression> expressions = new ArrayList<AstExpression>();
  AstExpression expr;
    expr = expression();
                        expressions.add(expr);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      expr = expression();
                                                                                 expressions.add(expr);
    }
    {if (true) return expressions;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression expression() throws ParseException {
  AstExpression expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case TRUE:
    case MINUS:
    case LEFT_PARENTHESIS:
    case NOT:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      expression = operatorExpression();
      break;
    case NEW:
      expression = newExpression();
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression operatorExpression() throws ParseException {
  AstExpression leftExpr = null;
  AstExpression rightExpr = null;
  Token operatorToken;
    leftExpr = logicalOrTerm();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_17;
      }
      operatorToken = jj_consume_token(OR);
      rightExpr = logicalOrTerm();
       leftExpr = new AstOperatorExpression(leftExpr, rightExpr, operatorToken.image, operatorToken.beginLine);
    }
     {if (true) return leftExpr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression logicalOrTerm() throws ParseException {
  AstExpression leftExpr = null;
  AstExpression rightExpr = null;
  Token operatorToken;
    leftExpr = logicalAndTerm();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_18;
      }
      operatorToken = jj_consume_token(AND);
      rightExpr = logicalAndTerm();
      leftExpr = new AstOperatorExpression(leftExpr, rightExpr, operatorToken.image, operatorToken.beginLine);
    }
    {if (true) return leftExpr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression logicalAndTerm() throws ParseException {
  AstExpression leftExpr = null;
  AstExpression rightExpr = null;
  Token operatorToken;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case TRUE:
    case MINUS:
    case LEFT_PARENTHESIS:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      leftExpr = comparativeTerm();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case NOT_EQUAL:
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_THAN_OR_EQUAL:
      case GREATER_THAN_OR_EQUAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUAL:
          operatorToken = jj_consume_token(EQUAL);
          break;
        case NOT_EQUAL:
          operatorToken = jj_consume_token(NOT_EQUAL);
          break;
        case LESS_THAN:
          operatorToken = jj_consume_token(LESS_THAN);
          break;
        case LESS_THAN_OR_EQUAL:
          operatorToken = jj_consume_token(LESS_THAN_OR_EQUAL);
          break;
        case GREATER_THAN:
          operatorToken = jj_consume_token(GREATER_THAN);
          break;
        case GREATER_THAN_OR_EQUAL:
          operatorToken = jj_consume_token(GREATER_THAN_OR_EQUAL);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        rightExpr = comparativeTerm();
          leftExpr = new AstOperatorExpression(leftExpr, rightExpr, operatorToken.image, operatorToken.beginLine);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      break;
    case NOT:
      leftExpr = negativeExpression();
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return leftExpr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression comparativeTerm() throws ParseException {
  AstExpression leftExpr = null;
  AstExpression rightExpr = null;
  Token operatorToken;
    leftExpr = term();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        operatorToken = jj_consume_token(MINUS);
        break;
      case PLUS:
        operatorToken = jj_consume_token(PLUS);
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rightExpr = term();
      leftExpr = new AstOperatorExpression(leftExpr, rightExpr, operatorToken.image, operatorToken.beginLine);
    }
    {if (true) return leftExpr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression negativeExpression() throws ParseException {
  Token negativeToken;
  int countUnaries = 0;
  AstExpression expression;
    label_20:
    while (true) {
      negativeToken = jj_consume_token(NOT);
                            countUnaries++;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_20;
      }
    }
    expression = factor();
    for (int i = 0; i < countUnaries; i++) {
        expression = new AstUnaryOperatorExpression(expression, negativeToken.image, negativeToken.beginLine);
    }
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression term() throws ParseException {
  AstExpression leftExpr = null;
  AstExpression rightExpr = null;
  Token operatorToken;
    leftExpr = factor();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_21;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        operatorToken = jj_consume_token(MULTIPLY);
        break;
      case DIVIDE:
        operatorToken = jj_consume_token(DIVIDE);
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rightExpr = factor();
        leftExpr = new AstOperatorExpression(leftExpr, rightExpr, operatorToken.image, operatorToken.beginLine);
    }
    {if (true) return leftExpr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression factor() throws ParseException {
  AstExpression expression;
  Token factorToken;
  Token minusToken = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case LEFT_PARENTHESIS:
    case INTEGER_LITERAL:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        minusToken = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        expression = complexAccess();
        break;
      case INTEGER_LITERAL:
        factorToken = jj_consume_token(INTEGER_LITERAL);
            expression = new AstIntegerLiteral(Integer.parseInt(factorToken.image), factorToken.beginLine);
        break;
      case LEFT_PARENTHESIS:
        jj_consume_token(LEFT_PARENTHESIS);
        expression = expression();
        jj_consume_token(RIGHT_PARENTHESIS);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case TRUE:
      factorToken = jj_consume_token(TRUE);
                              expression = new AstBooleanLiteral(true, factorToken.beginLine);
      break;
    case FALSE:
      factorToken = jj_consume_token(FALSE);
                               expression = new AstBooleanLiteral(false, factorToken.beginLine);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (minusToken != null) {
      /* -45 ==  0 - 45*/
      {if (true) return new AstOperatorExpression(new AstIntegerLiteral(0, minusToken.beginLine), expression, minusToken.image, minusToken.beginLine);}
    } else {
      {if (true) return expression;}
    }
    throw new Error("Missing return statement in function");
  }

  final public AstExpression complexAccess() throws ParseException {
  AstExpression expr;
  AstExpression arrayAccess;
  List<AstExpression> arguments = null;
  AstVariable baseVariable;
  AstArrayVariable arrayVariable;
  AstClassVariable classVariable;
  Token nameToken;
    nameToken = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PARENTHESIS:
      jj_consume_token(LEFT_PARENTHESIS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FALSE:
      case TRUE:
      case NEW:
      case MINUS:
      case LEFT_PARENTHESIS:
      case NOT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        arguments = arguments();
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PARENTHESIS);
          // Creating the function expression with its arguments.
          AstFunctionCallExpression functionExpr =
              new AstFunctionCallExpression(nameToken.image, nameToken.beginLine);
          if (arguments != null) {
            for (AstExpression arg : arguments)
              functionExpr.addAstExpression(arg);
          }

          expr = functionExpr;
      break;
    default:
      jj_la1[55] = jj_gen;
          // Defining the base variable (x)
          baseVariable = new AstBaseVariable(nameToken.image, nameToken.beginLine);
          expr = new AstVariableExpression(baseVariable, nameToken.beginLine);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_BRACKET:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_22;
        }
        // Represents the derivations ( a[3][43][4] )
                  arrayAccess = arrayAccess();
            arrayVariable = new AstArrayVariable(baseVariable, arrayAccess, nameToken.beginLine);
            expr = new AstVariableExpression(arrayVariable, nameToken.beginLine);
            baseVariable = arrayVariable;
      }
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_23;
        }
        jj_consume_token(DOT);
        nameToken = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_PARENTHESIS:
          jj_consume_token(LEFT_PARENTHESIS);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FALSE:
          case TRUE:
          case NEW:
          case MINUS:
          case LEFT_PARENTHESIS:
          case NOT:
          case INTEGER_LITERAL:
          case IDENTIFIER:
            arguments = arguments();
            break;
          default:
            jj_la1[52] = jj_gen;
            ;
          }
          jj_consume_token(RIGHT_PARENTHESIS);
                  // Creating the method expression with its arguments.
                  AstMethodVariable methodVariable =
                      new AstMethodVariable(baseVariable, nameToken.image, nameToken.beginLine);
                  if (arguments != null) {
                    for (AstExpression arg : arguments)
                      methodVariable.addAstExpression(arg);
                  }

                  expr = new AstMethodCallExpression(methodVariable, nameToken.beginLine);
                  baseVariable = methodVariable;
          break;
        default:
          jj_la1[54] = jj_gen;
                classVariable = new AstClassVariable(baseVariable, nameToken.image, nameToken.beginLine);
                expr = new AstVariableExpression(classVariable, nameToken.beginLine);
                baseVariable = classVariable;
          label_24:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LEFT_BRACKET:
              ;
              break;
            default:
              jj_la1[53] = jj_gen;
              break label_24;
            }
            arrayAccess = arrayAccess();
                      arrayVariable = new AstArrayVariable(baseVariable, arrayAccess, nameToken.beginLine);
                      expr = new AstVariableExpression(arrayVariable, nameToken.beginLine);
                      baseVariable = arrayVariable;
          }
        }
      }
    }
    {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression arrayAccess() throws ParseException {
  AstExpression expression;
    jj_consume_token(LEFT_BRACKET);
    expression = expression();
    jj_consume_token(RIGHT_BRACKET);
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public AstExpression newExpression() throws ParseException {
  AstExpression expression;
  AstExpression arrayAccess;
  List<AstExpression> arguments = null;
  int arrayDimension = 1;   // It is already of one dimension.
  Token tokenType;
  Token tokenNew;
    tokenNew = jj_consume_token(NEW);
    tokenType = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PARENTHESIS:
      jj_consume_token(LEFT_PARENTHESIS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FALSE:
      case TRUE:
      case NEW:
      case MINUS:
      case LEFT_PARENTHESIS:
      case NOT:
      case INTEGER_LITERAL:
      case IDENTIFIER:
        arguments = arguments();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(RIGHT_PARENTHESIS);
          AstNewClassExpression newClass = new AstNewClassExpression(tokenType.image, tokenNew.beginLine);
          if (arguments != null) {
            newClass.setExpressions(arguments);
          }

          expression = newClass;
      break;
    case LEFT_BRACKET:
      arrayAccess = arrayAccess();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_BRACKET:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_25;
        }
        jj_consume_token(LEFT_BRACKET);
        jj_consume_token(RIGHT_BRACKET);
                                                                        arrayDimension++;
      }
          expression = new AstNewArrayExpression(tokenType.image, arrayAccess, arrayDimension, tokenNew.beginLine);
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public SimpleJavaTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[59];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2000,0x0,0x20000000,0x80000000,0x20000000,0x0,0x0,0x20000000,0x0,0x80000000,0x0,0x0,0x20000000,0x802cc000,0x802cc000,0x0,0x1520000,0x0,0x38000000,0x0,0x18000000,0x20000000,0x0,0x1520000,0x20000000,0x0,0x0,0x20000000,0x0,0x18000000,0x1520000,0x38000000,0x10000,0x1520000,0x0,0x1520000,0x0,0x0,0x0,0x0,0x1120000,0x1800000,0x1800000,0x0,0x6000000,0x6000000,0x1000000,0x0,0x1120000,0x1520000,0x20000000,0x0,0x1520000,0x20000000,0x0,0x0,0x1520000,0x20000000,0x20000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x20000,0x0,0x20,0x22,0x20002,0x20000,0x0,0x20000,0x20,0x10,0x20000,0x0,0x20020,0x20020,0x20000,0x38002,0x20000,0x21008,0x10,0x1000,0x0,0x8,0x38002,0x0,0x2,0x10,0x0,0x1000,0x1000,0x38002,0x2102a,0x0,0x38002,0x10,0x38002,0x4000,0x2000,0xfc0,0xfc0,0x38002,0x0,0x0,0x8000,0x0,0x0,0x0,0x30002,0x30002,0x38002,0x0,0x8,0x38002,0x0,0x2,0x2,0x38002,0x0,0x2,};
   }

  /** Constructor with InputStream. */
  public SimpleJava(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleJava(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleJavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SimpleJava(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleJavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SimpleJava(SimpleJavaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SimpleJavaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[50];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 59; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 50; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
